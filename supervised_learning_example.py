# -*- coding: utf-8 -*-
"""Supervised_Learning_Example.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z4P6iDppREcfSfbfY10vYwIeZNHA4_Pw
"""

import zipfile
import os
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras import layers, models
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay, classification_report

# Path to the uploaded zip file
zip_path = 'traffic_light.zip'
# Folder where you want to extract the contents
extract_folder = 'dataset_traffic_light'
# Create the folder if it doesn't exist
if not os.path.exists(extract_folder):
  os.makedirs(extract_folder)
  # Extract the ZIP file into the datasetcnn folder
with zipfile.ZipFile(zip_path, 'r') as zip_ref:
  zip_ref.extractall(extract_folder)

print(f"Extraction complete! Files are extracted to the '{extract_folder}' folder.")

# Parameters
IMAGE_SIZE = (128, 128)
BATCH_SIZE = 64
EPOCHS = 15 # epoch for train models

# Data Generators
train_gen = ImageDataGenerator(
    rescale=1./255,
    rotation_range=20,
    zoom_range=0.2,
    width_shift_range=0.1,
    height_shift_range=0.1,
    shear_range=0.1,
    horizontal_flip=True
)

test_gen = ImageDataGenerator(rescale=1./255)

# load data / splitting data
train_data = train_gen.flow_from_directory(
    'dataset_traffic_light/traffic_light/dataset_traffic_light/data/train',
    target_size=IMAGE_SIZE,
    batch_size=BATCH_SIZE,
    class_mode='categorical'
)

test_data = test_gen.flow_from_directory(
    'dataset_traffic_light/traffic_light/dataset_traffic_light/data/test',
    target_size=IMAGE_SIZE,
    batch_size=BATCH_SIZE,
    class_mode='categorical',
    shuffle=False
)

# Build Model using Transfer Learning
base_model = MobileNetV2(input_shape=(128, 128, 3), include_top=False, weights='imagenet')
base_model.trainable = False  # Freeze the base model layers initially

# Define the full model matrix form
model = models.Sequential([
    base_model,
    layers.GlobalAveragePooling2D(),
    layers.Dense(128, activation='relu'),
    layers.Dropout(0.5),
    layers.Dense(train_data.num_classes, activation='softmax')
])

# Compile the model
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# Train the model
history = model.fit(train_data, validation_data=test_data, epochs=EPOCHS)

# Predict the classes on test data
pred_probs = model.predict(test_data)
pred_labels = np.argmax(pred_probs, axis=1)

# Get true labels and class names
true_labels = test_data.classes
class_names = list(test_data.class_indices.keys())

# Generate confusion matrix
cm = confusion_matrix(true_labels, pred_labels)

# Display confusion matrix
plt.figure(figsize=(8, 6))
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=class_names)
disp.plot(cmap=plt.cm.Blues, values_format='d')
plt.title("Confusion Matrix")
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Classification report
report = classification_report(true_labels, pred_labels, target_names=class_names)
print("Classification Report:\n")
print(report)

